<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS10语音识别]]></title>
    <url>%2F2017%2F05%2F21%2FiOS10%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[iOS10苹果开放了语音识别接口，这让我们可以自己自由的把音频转为文本了。iOS的语音识别主要分为识别音频文件和识别音频缓存（按我的理解就是识别音频输入流达到实时转换的效果）。因为iOS10对权限的要求更严格了所以在一切的工作之前我们要在info.plist文件里面增加两个节点。第一个节点： 1key: Privacy - Speech Recognition Usage Description value:语音识别（这个值可以自定义，需要你描述Speech Recognition的用法） 第二个节点： 1key: Privacy - Microphone Usage Description value:麦克风（这个值也是自定义的，同样是用来描述Microphone的用法的） 下面我们看看怎么识别音频文件：首先我们要请求权限，+ (void)requestAuthorization:(void(^)(SFSpeechRecognizerAuthorizationStatus status))handler这个方法是SFSpeechRecognizer的类方法，SFSpeechRecognizerAuthorizationStatus是个枚举类型表示请求权限的结果，只有当status的值是SFSpeechRecognizerAuthorizationStatusAuthorized时才表示有使用语音识别的权限，增枚举类型的其他三个成员值分别是：用户未决定SFSpeechRecognizerAuthorizationStatusNotDetermined、拒绝SFSpeechRecognizerAuthorizationStatusDenied、不支持SFSpeechRecognizerAuthorizationStatusRestricted看代码： 1234567//请求权限 [SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; if (status == SFSpeechRecognizerAuthorizationStatusAuthorized) &#123; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;speech&quot; withExtension:@&quot;m4a&quot;]; [self recognizeAudioFile:url]; &#125; &#125;]; 然后我们再看具体的怎么进行语音识别：SFSpeechRecognizer这个类是具体用来进行语音识别的，默认初始化方法init表示识别本地语言环境，就是说如果你手机是中文那么你说中文就可以直接识别了。当然了如果我们想指定识别某种语言就要使用：- (nullable instancetype)initWithLocale:(NSLocale *)locale 这个方法进行初始化了。然后我们再创建一个SFSpeechURLRecognitionRequest类的实例，这个实例包含了音频信息。最后再调用SFSpeechRecognizer实例的 12- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 方法，将音频信息传给苹果的服务器然后，苹果会直接返回转换后的信息。直接看代码： 12345678910SFSpeechRecognizer *recongize = [[SFSpeechRecognizer alloc] init]; SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url]; [recongize recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 到此为止已经完成了音频文件的识别了。下面我们再说说怎样实时识别音频输入流：识别音频输入流的步骤与上面的大体相似，最主要的不同是音频资源的区别一个是直接从文件获取另外一个是从AVAudioNode的输出数据获取的。所以我们首先要开启麦克风获取AVAudioNode输出的音频信息，这部分就不细说了直接看代码： 123456789101112131415161718192021222324252627282930313233AVAudioSession *session = [AVAudioSession sharedInstance]; NSError *error; [session setCategory:AVAudioSessionCategoryRecord error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setMode:AVAudioSessionModeMeasurement error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setActive:YES withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; if (!auengine.inputNode) &#123; self.speechText.text = @&quot;无输入节点&quot;; return; &#125; [auengine.inputNode installTapOnBus:0 bufferSize:1024 format:[auengine.inputNode outputFormatForBus:0] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; if (buffer) &#123; [requestbuffer appendAudioPCMBuffer:buffer]; &#125; &#125;]; [auengine prepare]; [auengine startAndReturnError:&amp;error]; 这样我们在- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock这个方法的block里面就可以获取到输出的音频信息，接下来我们再识别这个信息：第一步都是创建一个SFSpeechRecognizer实例，第二步有区别我们要创建SFSpeechAudioBufferRecognitionRequest这个对象的实例，第三步还一样的调用：- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 的方法。 看代码： 1234567891011SFSpeechRecognizer *recognize = [[SFSpeechRecognizer alloc] init]; SFSpeechAudioBufferRecognitionRequest *requestbuffer = [[SFSpeechAudioBufferRecognitionRequest alloc] init]; [recognize recognitionTaskWithRequest:requestbuffer resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 完整的源码已经上传到了github,下载源码]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取通讯录]]></title>
    <url>%2F2017%2F05%2F21%2FiOS%E8%8E%B7%E5%8F%96%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[##获取通讯录有的时候我们需要获取用户的通讯录信息上传给服务器，对于iOS来说iOS9之前和之后有不同的方法用于获取通讯录信息。 iOS9之前在9之前的版本获取通讯录信息是通过ABAddressBookCopyArrayOfAllPeople 来获取所有联系人的信息的。所有的联系人信息被保存在一个数组里面，我们只需要遍历整个数组就可以获取我们想要的信息的。下面以获取所有联系人的姓名和电话号码和唯一识别码为例，提供一个简单的函数：12345678910111213141516171819202122232425262728293031323334- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125; iOS9之后在iOS9之后，苹果为方便获取通讯录提供了一套API,开发者可以通过CNContactStore 这个类获取需要的信息,这个类有个实例方法:enumerateContactsWithFetchRequest: error:usingBlock: ,每获取到一个联系人信息这个方法的回调函数就会执行一次。 This method waits until the enumeration is finished. If there are no results, the block is not called and the method returns YES.This can be used to fetch all contacts without keeping all of them at once in memory because this is expensive. 上面是苹果开发文档里面的一段话，这个方法是同步的阻塞当前线程。所以我们可以很方便地获取所有的联系人信息。下面是在iOS9以后获取所有联系人的姓名电话号码和唯一身份识别码的一个方法:12345678910111213141516171819202122232425262728293031- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125; 当然了事情到这里还没有结束，在获取通讯录之前我们需要用户授权。 获取用户授权获取用户授权主要思路是每次访问通讯录之前会检查授权情况如果已经授权直接访问通讯录，如果拒绝授权给出提示跳转应用设置页面引导用户打开授权，如果未授权则发起授权请求。问题比较简单就不加赘述，直接看代码: iOS9之前12345678910111213141516171819202122- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125; iOS9之后123456789101112131415161718192021222324- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125; 完整代码下面是封装的一个获取手机通讯录的类 123456789#import &lt;Foundation/Foundation.h&gt;#import &lt;Contacts/Contacts.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;AddressBook/AddressBook.h&gt;#import &quot;UIViewController+Tools.h&quot;#import &quot;FWDefine.h&quot;@interface FWAddressBook : NSObject- (void)accessAddressBook:(void(^)(NSArray *))completionHandler;@end ———————————123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#import &quot;FWAddressBook.h&quot;@implementation FWAddressBook- (void)accessAddressBook:(void(^)(NSArray * models))completionHandler &#123; if ([self terminate]) return; if (Before9) &#123; [self accessAddressBookBefore9:completionHandler]; &#125;else &#123; [self accessAddressBookLater9:completionHandler]; &#125;&#125;- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125;- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125;- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125;- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125;- (void)alert &#123; UIViewController *controller = [UIApplication sharedApplication].keyWindow.rootViewController; [controller alertSure:^&#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; message:@&quot;为了成功贷款，请您前往设置页面允许应用访问通讯录&quot;];&#125;- (BOOL)terminate &#123; NSDate *date = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;time&quot;]; NSDate *currentDate = [NSDate date]; if (date) &#123; NSTimeInterval time = [currentDate timeIntervalSinceDate:date]; if (time &lt; 24*60*60) return YES; [self saveTime:currentDate]; &#125;else &#123; [self saveTime:currentDate]; &#125; return NO;&#125;- (void)saveTime:(NSDate *)time &#123; [[NSUserDefaults standardUserDefaults] setObject:time forKey:@&quot;time&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];&#125;@end]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppStore账号申请]]></title>
    <url>%2F2017%2F05%2F20%2FAppStore%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[1.申请Apple ID1.1 请点击进入苹果开发者网站1.2 进入网页后点击右上角的Account标签进入新页面，点击创建App ID1.3 填写信息创建Apple ID2.申请邓白氏码2.1 请点击进入苹果开发者网站2.2 点击网页上方的Support标签，进入新页面点击Membership 2.3 选择邓白氏编码 D-U-N-S Number点击 2.4 点击D-U-N-S Number look up tool 连接在收到邓白氏码后请求公司账号的时候请注意时间问题 Receiving and Managing Your D-U-N-S NumberAfter requesting a D-U-N-S Number, please allow up to 5 business days to receive your number from D&amp;B. Expediting your D-U-N-S Number creation process will not shorten this waiting period. If your application has taken longer than two weeks to process, please email D&amp;B.Once you receive your D-U-N-S Number, please allow up to 2 business days for Apple to receive your information from D&amp;B. After this period, you may enroll as a company/organization in the Apple Developer Program.To update your D&amp;B profile, please email D&amp;B. It takes up to 14 business days for D&amp;B to provide updated information to Apple. 在点击后如果你没有登录苹果开发者网站系统会让你登陆，请用第一步申请到的Apple ID和密码进行登陆。 2.5 填写公司信息公司信息填写完成后点击右下角的Continue,进入下一页面。如果你的公司没有邓白氏编码你可以请求一个邓白氏编码。 2.6 请求公司的邓白氏编码提交申请后请注册查看来自邓白氏公司的邮件。在请求邓白氏编码的时候会接受到来自邓白氏的邮件和回访电话，在此期间按照要求提供材料就可以了,在此期间你需要的是耐心等待 3.注册成为苹果公司开发者3.1 点击进入苹果官网 点击右上角蓝色的Enroll按钮进入下一页。后继续点击页面下方蓝色的按钮:Start Your Enrollment 3.2 选择成为公司开发者 3.3 填写申请信息 3.4 校验信息提交申请]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化发布工具fastlane]]></title>
    <url>%2F2017%2F05%2F19%2FiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7fastlane%2F</url>
    <content type="text"><![CDATA[fastlane初识 fastlane 是一个很棒的iOS和Andriod的一个自动化版本发布工具，它提供了一系列的插件用来解决打包发布上传应用市场这个过程一系列的问题。本教程将介绍如何通过fastlane来自动化上传一个应用到AppStore fastlane环境搭建 在一切开始之前你需要确定你的电脑上有最新的Xcode命令行工具在终端输入：xcode-select --install 安装fastlane:你有三种方式在你的电脑上安装fastlane 使用命令行brew cask install fastlane 通过homewbrew软件包管理器安装 使用命令行sudo gem install fastlane -NV 通过gem安装 如果你使用上面的命令行安装出错了，那么你可以直接点击连接下载安装包来安装fastlane 初始化:进入你app的根目录下执行命令行 fastlane init 至此你将可以通过fastlane来管理你项目的发布过程。 fastlane的常用插件produce Creates the given application on iTC and the Dev Portal if necessaryproduce插件是用来在iTunes Connect里面创建你自己的应用的（如果有则不创建） procuce有很多可选参数，下面简单介绍几个: username 用户名，这个就是你的appid账号 team_id 团队id，这个是你所在团队的id app_identifier 你应用的唯一标识符,可以填bundle Id app_name 你应用的名称 language 应用支持的语言，简体中文：Simplified Chinese app_version app的版本号 1.0 sku 套装id，简单点直接写bundle Id 1234567891011lane :createApp do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier] )end 我们可以使用lane 定义一个代码块用来封装我们需要的功能，同时可以使用options来配置参数 更多可用参数请点击这里More cert Fetch or generate the latest available code signing identity cret插件可以用来获取最新的代码签名证书,官方推荐配合match插件使用（如果你需要进行团队合作） 介绍几个cert的可选参数: username 用户名，你的苹果开发者账号 team_id 团队的Id 1234cert( username: options[:username], team_id: options[:teamid] ) 更多可用的参数请点击这里More pem Makes sure a valid push profile is active and creates a new one if neededpem 插件是用来创建iOS推送证书的，它会先确定是否有一个可用的推送证书如果有需要会创建一个新的推送证书 可选参数: username 用户名，就是你的开发者账号 team_id 团队的Id p12_password 用于p12文件的密码 generate_p12 创建一个p12文件 output_path 导出的证书钥匙串等的存放目录 12345678pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) 更多可用的参数请点击这里More sigh Generates a provisioning profile. Stores the profile in the current folder .sigh 是用来创建配置文件provisioning的如果需要进行团队合作建议配合match插件使用sigh 可选参数: force 是否更新配置文件 app_identifier app的唯一标识符 bundleId id username 用户名，你的苹果开发者账号 team_id 团队的Id 123456sigh( force: true, username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier] ) 更多可用的参数请点击这里More gym Easily build and sign your app using gymgym插件可以对你的项目进行编译打包并且进行签名 可用的参数: scheme 待编译工程的schem，可以使用命令行xcodebuild -list来获取可用的schem值 clean 是否在编译之前清理工程 silent 是否隐藏不必要信息 output_directory 编译好的ipa包的存放目录 1234gym( silent: true, clean: true ) 更多可用的参数请点击这里More snapshot Generate new localised screenshots on multiple devices自动截图工具，可以对应用截图自动生成iTunes Connect需要的预览图片 可用参数: devices 截图时使用的机器 languages 使用的语言 output_directory 生成图片的导出目录 当然了，你可以使用命令fastlane snapshot init 来自动生成截图需要的配置，在自动生成的Snapfile文件里面会有一些提供好的参数可供选择 1234desc &quot;snapshot&quot; lane :shot do snapshot end 截图插件的详细使用方式请点击这里 更多可用的参数请点击这里More deliver Uses deliver to upload new app metadata and builds to iTunes Connect上传ipa包到iTunes Connect 可用的参数: app_identifier 应用的bundle id username 开发者账号 12345deliver( app_identifier: options[:appidentifier], username: options[:username] ) 更多可用的参数请点击这里More fastlane buildupload这里提供一个可用的demo来对工程进行自动化打包上传 12345678910111213141516171819202122232425262728293031323334353637383940desc &quot;build your application to an ipa and upload the ipa&quot;desc &quot;if you want upload an ipa to itunes Connect ,please use command line : fastlane buildupload&quot; lane :buildupload do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier], ) cert( username: options[:username], team_id: options[:teamid] ) pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) sigh( force: true, username: options[:username], # team_id: options[:teamid], app_identifier: options[:appidentifier] ) clear_derived_data gym( silent: true, clean: true) deliver( app_identifier: options[:appidentifier], username: options[:username] ) end 调用命令：fastlane buildupload 参数1 参数2 参数3 ... 使用shell修改工程配置 在很多情况下我们使用自动化打包工具都是需要批量处理很多工程编译出不同的IPA包的，这就需要我们在使用fastlane之前先修改一些工程的配置 从svn或者git等仓库里面checkout 代码 12rm -rf deploysvn co svn://xxx/xxx/xxx/xxx deploy 从文件里面读取配置信息到数组如: 123456i=0for s in `cat params/appname.txt`do appnames[$&#123;i&#125;]=$&#123;s&#125; i=$&#123;i&#125;+1 done appname.txt文件里面一行写一个app的名字，有几个app就写几行其他的诸如bundle id ，username 等信息类似 修改应用的bundle Id sed -i &#39;&#39; &quot;s/com.xxx.xxx/$1/g&quot; xxx.xcodeproj/project.pbxproj $1，参数一是新的bundle id 修改应用名称 /usr/libexec/PlistBuddy -c &quot;Set :CFBundleDisplayName $2&quot; Jubaodai/Info.plist $2是新的应用名称 修改应用的icons图片 cp -r ../pictures/$2/AppIcon.appiconset/. xxx/Assets.xcassets/AppIcon.appiconset 修改fastlane 元数据里面的应用名称 echo newAppName &gt; fastlane/metadata/zh-Hans/name.txt 修改fastlane 里面上传iTunes Connect 的icon图片 cp ../pictures/$1/app_icon.jpg fastlane/metadata/app_icon.jpg 调用fastlane 进行自动打包 fastlane buildupload username:${usernames[${i}]} teamid:${teamids[${i}]} appidentifier:${appidentifiers[${i}]} appname:${appnames[${i}]}]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>