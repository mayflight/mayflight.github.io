<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS10语音识别]]></title>
    <url>%2F2017%2F05%2F21%2FiOS10%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[iOS10苹果开放了语音识别接口，这让我们可以自己自由的把音频转为文本了。iOS的语音识别主要分为识别音频文件和识别音频缓存（按我的理解就是识别音频输入流达到实时转换的效果）。因为iOS10对权限的要求更严格了所以在一切的工作之前我们要在info.plist文件里面增加两个节点。第一个节点： 1key: Privacy - Speech Recognition Usage Description value:语音识别（这个值可以自定义，需要你描述Speech Recognition的用法） 第二个节点： 1key: Privacy - Microphone Usage Description value:麦克风（这个值也是自定义的，同样是用来描述Microphone的用法的） 下面我们看看怎么识别音频文件：首先我们要请求权限，+ (void)requestAuthorization:(void(^)(SFSpeechRecognizerAuthorizationStatus status))handler这个方法是SFSpeechRecognizer的类方法，SFSpeechRecognizerAuthorizationStatus是个枚举类型表示请求权限的结果，只有当status的值是SFSpeechRecognizerAuthorizationStatusAuthorized时才表示有使用语音识别的权限，增枚举类型的其他三个成员值分别是：用户未决定SFSpeechRecognizerAuthorizationStatusNotDetermined、拒绝SFSpeechRecognizerAuthorizationStatusDenied、不支持SFSpeechRecognizerAuthorizationStatusRestricted看代码： 1234567//请求权限 [SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; if (status == SFSpeechRecognizerAuthorizationStatusAuthorized) &#123; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;speech&quot; withExtension:@&quot;m4a&quot;]; [self recognizeAudioFile:url]; &#125; &#125;]; 然后我们再看具体的怎么进行语音识别：SFSpeechRecognizer这个类是具体用来进行语音识别的，默认初始化方法init表示识别本地语言环境，就是说如果你手机是中文那么你说中文就可以直接识别了。当然了如果我们想指定识别某种语言就要使用：- (nullable instancetype)initWithLocale:(NSLocale *)locale 这个方法进行初始化了。然后我们再创建一个SFSpeechURLRecognitionRequest类的实例，这个实例包含了音频信息。最后再调用SFSpeechRecognizer实例的 12- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 方法，将音频信息传给苹果的服务器然后，苹果会直接返回转换后的信息。直接看代码： 12345678910SFSpeechRecognizer *recongize = [[SFSpeechRecognizer alloc] init]; SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url]; [recongize recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 到此为止已经完成了音频文件的识别了。下面我们再说说怎样实时识别音频输入流：识别音频输入流的步骤与上面的大体相似，最主要的不同是音频资源的区别一个是直接从文件获取另外一个是从AVAudioNode的输出数据获取的。所以我们首先要开启麦克风获取AVAudioNode输出的音频信息，这部分就不细说了直接看代码： 123456789101112131415161718192021222324252627282930313233AVAudioSession *session = [AVAudioSession sharedInstance]; NSError *error; [session setCategory:AVAudioSessionCategoryRecord error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setMode:AVAudioSessionModeMeasurement error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setActive:YES withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; if (!auengine.inputNode) &#123; self.speechText.text = @&quot;无输入节点&quot;; return; &#125; [auengine.inputNode installTapOnBus:0 bufferSize:1024 format:[auengine.inputNode outputFormatForBus:0] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; if (buffer) &#123; [requestbuffer appendAudioPCMBuffer:buffer]; &#125; &#125;]; [auengine prepare]; [auengine startAndReturnError:&amp;error]; 这样我们在- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock这个方法的block里面就可以获取到输出的音频信息，接下来我们再识别这个信息：第一步都是创建一个SFSpeechRecognizer实例，第二步有区别我们要创建SFSpeechAudioBufferRecognitionRequest这个对象的实例，第三步还一样的调用：- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 的方法。 看代码： 1234567891011SFSpeechRecognizer *recognize = [[SFSpeechRecognizer alloc] init]; SFSpeechAudioBufferRecognitionRequest *requestbuffer = [[SFSpeechAudioBufferRecognitionRequest alloc] init]; [recognize recognitionTaskWithRequest:requestbuffer resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 完整的源码已经上传到了github,下载源码]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取通讯录]]></title>
    <url>%2F2017%2F05%2F21%2FiOS%E8%8E%B7%E5%8F%96%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[##获取通讯录有的时候我们需要获取用户的通讯录信息上传给服务器，对于iOS来说iOS9之前和之后有不同的方法用于获取通讯录信息。 iOS9之前在9之前的版本获取通讯录信息是通过ABAddressBookCopyArrayOfAllPeople 来获取所有联系人的信息的。所有的联系人信息被保存在一个数组里面，我们只需要遍历整个数组就可以获取我们想要的信息的。下面以获取所有联系人的姓名和电话号码和唯一识别码为例，提供一个简单的函数：12345678910111213141516171819202122232425262728293031323334- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125; iOS9之后在iOS9之后，苹果为方便获取通讯录提供了一套API,开发者可以通过CNContactStore 这个类获取需要的信息,这个类有个实例方法:enumerateContactsWithFetchRequest: error:usingBlock: ,每获取到一个联系人信息这个方法的回调函数就会执行一次。 This method waits until the enumeration is finished. If there are no results, the block is not called and the method returns YES.This can be used to fetch all contacts without keeping all of them at once in memory because this is expensive. 上面是苹果开发文档里面的一段话，这个方法是同步的阻塞当前线程。所以我们可以很方便地获取所有的联系人信息。下面是在iOS9以后获取所有联系人的姓名电话号码和唯一身份识别码的一个方法:12345678910111213141516171819202122232425262728293031- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125; 当然了事情到这里还没有结束，在获取通讯录之前我们需要用户授权。 获取用户授权获取用户授权主要思路是每次访问通讯录之前会检查授权情况如果已经授权直接访问通讯录，如果拒绝授权给出提示跳转应用设置页面引导用户打开授权，如果未授权则发起授权请求。问题比较简单就不加赘述，直接看代码: iOS9之前12345678910111213141516171819202122- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125; iOS9之后123456789101112131415161718192021222324- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125; 完整代码下面是封装的一个获取手机通讯录的类 123456789#import &lt;Foundation/Foundation.h&gt;#import &lt;Contacts/Contacts.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;AddressBook/AddressBook.h&gt;#import &quot;UIViewController+Tools.h&quot;#import &quot;FWDefine.h&quot;@interface FWAddressBook : NSObject- (void)accessAddressBook:(void(^)(NSArray *))completionHandler;@end ———————————123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#import &quot;FWAddressBook.h&quot;@implementation FWAddressBook- (void)accessAddressBook:(void(^)(NSArray * models))completionHandler &#123; if ([self terminate]) return; if (Before9) &#123; [self accessAddressBookBefore9:completionHandler]; &#125;else &#123; [self accessAddressBookLater9:completionHandler]; &#125;&#125;- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125;- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125;- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125;- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125;- (void)alert &#123; UIViewController *controller = [UIApplication sharedApplication].keyWindow.rootViewController; [controller alertSure:^&#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; message:@&quot;为了成功贷款，请您前往设置页面允许应用访问通讯录&quot;];&#125;- (BOOL)terminate &#123; NSDate *date = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;time&quot;]; NSDate *currentDate = [NSDate date]; if (date) &#123; NSTimeInterval time = [currentDate timeIntervalSinceDate:date]; if (time &lt; 24*60*60) return YES; [self saveTime:currentDate]; &#125;else &#123; [self saveTime:currentDate]; &#125; return NO;&#125;- (void)saveTime:(NSDate *)time &#123; [[NSUserDefaults standardUserDefaults] setObject:time forKey:@&quot;time&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];&#125;@end]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift构造过程1]]></title>
    <url>%2F2017%2F05%2F21%2FSwift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[Swift 的类、结构体、枚举构造完成后它们的所有存储属性一定有一个值 存储属性可以在声明的时候直接给定一个默认值或者在构造的时候赋值,可选属性在初始化的时候会被赋值nil 构造器的语法自定义外部参数名称123456789101112struct Counter &#123; let max : Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125;&#125; 我们定义一个结构体Counter,并提供一个构造器init(maxValue a : Int,minValue b:Int) 类似于函数这个构造器我们可以指定外部参数名称(maxValue,minValue)用于区分不同的构造器。 对于存储属性我们既可以在声明的时候给定默认值也可以在构造的过程中重新设置，如在上面的构造过程中只有当b&lt;0时才对min赋值。对于常量属性我们可以在构造的过程中赋值(没有默认值的情况) 对于可选属性如果我们在构造的过程中没有给它赋值，它将自动获得一个值nil 上面的构造器可以这样调用：var a = Counter(maxValue: 100, minValue:0) 默认外部参数名称123456789101112131415161718struct Counter &#123; let max:Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125; //默认外部参数名称 init(max:Int) &#123; self.max = max min = 0 &#125;&#125; 构造器init(max:Int) 我们并没有显示声明函数外部名称它将自动获得一个与内部名称一样的外部名称 在构造器里面我们可以使用属性名直接引用属性，但是如果构造器的内部参数名称与属性名重名可以使用self.propertyName这个格式来引用属性 上面的构造器可以这样调用:var b = Counter(max: 50) 忽略外部参数名称123456789101112131415161718192021222324252627struct Counter &#123; let max:Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125; //默认外部参数名称 init(max:Int) &#123; self.max = max min = 0 &#125; //忽略外部参数名称 init(_ a:Int,_ b:Int) &#123; //值类型的构造器代理(枚举和结构体) if a &gt; b &#123; self.init(maxValue: a, minValue: b) &#125;else &#123; self.init(maxValue: b, minValue: a) &#125; &#125; &#125; 如果我们不想使用外部参数名称可以用_表示忽略 对于值类型来说在一个构造器中可以直接代理它本身的其他构造器来完成一部分构造过程 上面的构造器可以这样调用:var c = Counter(20,100) 默认构造器 如果结构体和类所有的属性都有默认值它们将自动获得一个默认构造器 12345class Person &#123; var givenName = "仙贝" var lastName = "落霞" var age:Int?&#125; 对于类（也可以是结构体）来说,如果它的所有属性都有存在一个默认值它将自动获得一个默认构造器，你可以使用默认构造器来初始化这个类:var f = Person() 结构体的逐一成员构造器1234567struct Color &#123; //如果结构体或者类所有的属性都都有默认值，它将自动获得一个默认构造器 //如果结构体没有自定义构造器它将自动获得逐一成员构造器（常量属性除外） var r = 124 let g = 255 var b:Int?&#125; 如果结构体没有自定义构造器它将获得一个逐一成员构造器，对于上面的结构体Color你可以通过两种方法初始化： 通过默认构造器var d = Color() 通过结构体逐一成员构造器 var e = Color(r: 255, b: 244) ##END下一篇 我们将说说类的构造]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift构造过程2]]></title>
    <url>%2F2017%2F05%2F21%2FSwift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[Swift中类的构造过程分为两个阶段 每个存储属性在它们被引入的类中会被指定一个初始值当所有的存储属性都有一个初始值后第二阶段开始。 在新实例使用之前，允许每个类进一步定制它们的存储属性。 类的代理规则 子类中的指定构造器必须调用父类的指定构造器(如果本身是父类可以忽略这条) 一个类的便利构造器必须调用这个类的其他构造器（横向代理） 一个类的便利构造器必须最终调用这个类的指定构造器(向上代理) 类的指定构造器父类的指定构造器1234567891011121314class Book &#123; var boonName:String var bookPrice:Double var sendFriend:String &#123; get &#123; return boonName &#125; &#125; //指定构造器 init(name:String,price:Double) &#123; boonName = name; bookPrice = price &#125;&#125; 指定构造器的语法跟值类型构造器的语法相同 我们可以直接使用指定构造器来初始化一个实例如:var book3 = Book(name: &quot;Like&quot;, price: 99) 子类的指定构造器1234567891011class MyBook:Book &#123; var publicationDate:String //指定构造器 init(name:String,price:Double,date:String) &#123; publicationDate = date //规则1，指定构造器必须调用父类中的指定构造器 super.init(name: name, price: price) bookPrice = 100 &#125;&#125; MyBook这个类继承自Book，对于子类的指定构造器有如下需要注意的： 在子类的指定构造器中必须先给新引入的属性赋值 子类中的指定构造器必须代理父类中指定构造器super.init(...) 子类中指定构造器必须在代理父类中的指定构造器后再设置继承来的属性值，在之前设置继承的属性值会在调用父类的指定构造器过程中被覆盖的。 我们可以用MyBook的指定构造器初始化:var myBook5 = MyBook(name: &quot;Five&quot;, price: 9.9, date: &quot;1992&quot;) 类的便利构造器对于Book这个类我们新增两个便利构造器1234567convenience init(freeBookName:String) &#123; self.init(name: freeBookName, price: 0)&#125;convenience init() &#123; self.init(freeBookName:&quot;Love China&quot;)&#125; 对于MyBook这个类新增两个便利构造器12345678910convenience init(myBookName:String,price:Double) &#123; self.init(name: myBookName, price: price, date: &quot;today&quot;) if bookPrice &gt; 50 &#123; self.bookPrice = 50 &#125;&#125;convenience override init(name: String, price: Double) &#123; self.init(myBookName: name, price: price) self.publicationDate = &quot;2017&quot;&#125; 对于便利构造器我们有一下几点: 便利构造器必须先代理类中的其他构造器 便利构造器必须最终代理到指定构造器 在便利构造器必须先代理其他构造器再修改属性值 在构造器的第一阶段完成前是无法使用self，无法调用实例方法。 在便利构造器中我们必须在代理其他构造器后才可以是有self,实例方法 我们可以通过便利构造器来初始化一个实例:var myBook3 = MyBook(name: &quot;World&quot;, price: 22),其用法与指定构造器一样 类的可失败构造器 对于Book这个类新增一个可失败构造器 12345init?(highPrice:Double) &#123; if highPrice &lt; 100 &#123; return nil &#125; self.boonName = &quot;Price&quot; self.bookPrice = highPrice&#125; 可失败构造器的语法跟指定构造器的区别是在init后多了一个? 可失败构造器是指在构造过程当不满足某些条件时返回nil值,在使用可失败构造器初始化实例时返回的是一个可选 如果在子类的非可失败构造器中向上代理到父类的可失败构造器，那么需要对父类的可失败构造器的代理结果强制解包 我们可以这样来使用一个可失败构造器: 123456if var book4 = Book(highPrice: 55) &#123; book4.bookPrice book4.boonName&#125;else &#123; var book5 = Book(highPrice: 120)&#125; 类的必要构造器对于Book这个类，新增一个必要构造器1234required init (lowPrice:Double) &#123; boonName = &quot;Run&quot; bookPrice = lowPrice &#125; 必要构造器需要在构造器前面添加关键字 required 必要构造器要求子类也要重写这个构造器，并且子类重写的构造器也要添加关键字required 类的继承与重写类的继承Swift里面的类不会像OC里面子类会自动继承父类的构造方法，必须要满足一定条件子类才会继承父类的构造方法 当满足前提：子类中新引入的属性都有默认值时有下面的规则适用: 如果子类没有提供自己的指定构造器那么它将自动继承父类的指定构造器 - 如果子类有提供所有父类的指定构造器的实现（可以是通过满足前面条件继承来的也可以是在子类中重写的），那么子类将默认继承父类的便利构造器 类的重写子类可以对父类的构造器进行重写，对于重写有如下的一些总结： 如果父类有必要构造器，子类必须重写父类的必要构造器 子类可以将父类的指定构造器重写成子类的指定构造器，在构造器前加关键字override 子类可以将父类的指定构造器重写成为子类的便利构造器，在构造器前加关键字convenience override 子类严格意义来说是无法重写父类的便利构造的，但是可以在子类中指定一个跟父类的便利构造器一下的构造器实现，这个构造器可以是子类的便利构造器也可以是子类的指定构造器，无论是哪种都不要有override关键字]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppStore账号申请]]></title>
    <url>%2F2017%2F05%2F20%2FAppStore%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[1.申请Apple ID1.1 请点击进入苹果开发者网站1.2 进入网页后点击右上角的Account标签进入新页面，点击创建App ID1.3 填写信息创建Apple ID2.申请邓白氏码2.1 请点击进入苹果开发者网站2.2 点击网页上方的Support标签，进入新页面点击Membership 2.3 选择邓白氏编码 D-U-N-S Number点击 2.4 点击D-U-N-S Number look up tool 连接在收到邓白氏码后请求公司账号的时候请注意时间问题 Receiving and Managing Your D-U-N-S NumberAfter requesting a D-U-N-S Number, please allow up to 5 business days to receive your number from D&amp;B. Expediting your D-U-N-S Number creation process will not shorten this waiting period. If your application has taken longer than two weeks to process, please email D&amp;B.Once you receive your D-U-N-S Number, please allow up to 2 business days for Apple to receive your information from D&amp;B. After this period, you may enroll as a company/organization in the Apple Developer Program.To update your D&amp;B profile, please email D&amp;B. It takes up to 14 business days for D&amp;B to provide updated information to Apple. 在点击后如果你没有登录苹果开发者网站系统会让你登陆，请用第一步申请到的Apple ID和密码进行登陆。 2.5 填写公司信息公司信息填写完成后点击右下角的Continue,进入下一页面。如果你的公司没有邓白氏编码你可以请求一个邓白氏编码。 2.6 请求公司的邓白氏编码提交申请后请注册查看来自邓白氏公司的邮件。在请求邓白氏编码的时候会接受到来自邓白氏的邮件和回访电话，在此期间按照要求提供材料就可以了,在此期间你需要的是耐心等待 3.注册成为苹果公司开发者3.1 点击进入苹果官网 点击右上角蓝色的Enroll按钮进入下一页。后继续点击页面下方蓝色的按钮:Start Your Enrollment 3.2 选择成为公司开发者 3.3 填写申请信息 3.4 校验信息提交申请]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化发布工具fastlane]]></title>
    <url>%2F2017%2F05%2F19%2FiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7fastlane%2F</url>
    <content type="text"><![CDATA[fastlane初识 fastlane 是一个很棒的iOS和Andriod的一个自动化版本发布工具，它提供了一系列的插件用来解决打包发布上传应用市场这个过程一系列的问题。本教程将介绍如何通过fastlane来自动化上传一个应用到AppStore fastlane环境搭建 在一切开始之前你需要确定你的电脑上有最新的Xcode命令行工具在终端输入：xcode-select --install 安装fastlane:你有三种方式在你的电脑上安装fastlane 使用命令行brew cask install fastlane 通过homewbrew软件包管理器安装 使用命令行sudo gem install fastlane -NV 通过gem安装 如果你使用上面的命令行安装出错了，那么你可以直接点击连接下载安装包来安装fastlane 初始化:进入你app的根目录下执行命令行 fastlane init 至此你将可以通过fastlane来管理你项目的发布过程。 fastlane的常用插件produce Creates the given application on iTC and the Dev Portal if necessaryproduce插件是用来在iTunes Connect里面创建你自己的应用的（如果有则不创建） procuce有很多可选参数，下面简单介绍几个: username 用户名，这个就是你的appid账号 team_id 团队id，这个是你所在团队的id app_identifier 你应用的唯一标识符,可以填bundle Id app_name 你应用的名称 language 应用支持的语言，简体中文：Simplified Chinese app_version app的版本号 1.0 sku 套装id，简单点直接写bundle Id 1234567891011lane :createApp do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier] )end 我们可以使用lane 定义一个代码块用来封装我们需要的功能，同时可以使用options来配置参数 更多可用参数请点击这里More cert Fetch or generate the latest available code signing identity cret插件可以用来获取最新的代码签名证书,官方推荐配合match插件使用（如果你需要进行团队合作） 介绍几个cert的可选参数: username 用户名，你的苹果开发者账号 team_id 团队的Id 1234cert( username: options[:username], team_id: options[:teamid] ) 更多可用的参数请点击这里More pem Makes sure a valid push profile is active and creates a new one if neededpem 插件是用来创建iOS推送证书的，它会先确定是否有一个可用的推送证书如果有需要会创建一个新的推送证书 可选参数: username 用户名，就是你的开发者账号 team_id 团队的Id p12_password 用于p12文件的密码 generate_p12 创建一个p12文件 output_path 导出的证书钥匙串等的存放目录 12345678pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) 更多可用的参数请点击这里More sigh Generates a provisioning profile. Stores the profile in the current folder .sigh 是用来创建配置文件provisioning的如果需要进行团队合作建议配合match插件使用sigh 可选参数: force 是否更新配置文件 app_identifier app的唯一标识符 bundleId id username 用户名，你的苹果开发者账号 team_id 团队的Id 123456sigh( force: true, username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier] ) 更多可用的参数请点击这里More gym Easily build and sign your app using gymgym插件可以对你的项目进行编译打包并且进行签名 可用的参数: scheme 待编译工程的schem，可以使用命令行xcodebuild -list来获取可用的schem值 clean 是否在编译之前清理工程 silent 是否隐藏不必要信息 output_directory 编译好的ipa包的存放目录 1234gym( silent: true, clean: true ) 更多可用的参数请点击这里More snapshot Generate new localised screenshots on multiple devices自动截图工具，可以对应用截图自动生成iTunes Connect需要的预览图片 可用参数: devices 截图时使用的机器 languages 使用的语言 output_directory 生成图片的导出目录 当然了，你可以使用命令fastlane snapshot init 来自动生成截图需要的配置，在自动生成的Snapfile文件里面会有一些提供好的参数可供选择 1234desc &quot;snapshot&quot; lane :shot do snapshot end 截图插件的详细使用方式请点击这里 更多可用的参数请点击这里More deliver Uses deliver to upload new app metadata and builds to iTunes Connect上传ipa包到iTunes Connect 可用的参数: app_identifier 应用的bundle id username 开发者账号 12345deliver( app_identifier: options[:appidentifier], username: options[:username] ) 更多可用的参数请点击这里More fastlane buildupload这里提供一个可用的demo来对工程进行自动化打包上传 12345678910111213141516171819202122232425262728293031323334353637383940desc &quot;build your application to an ipa and upload the ipa&quot;desc &quot;if you want upload an ipa to itunes Connect ,please use command line : fastlane buildupload&quot; lane :buildupload do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier], ) cert( username: options[:username], team_id: options[:teamid] ) pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) sigh( force: true, username: options[:username], # team_id: options[:teamid], app_identifier: options[:appidentifier] ) clear_derived_data gym( silent: true, clean: true) deliver( app_identifier: options[:appidentifier], username: options[:username] ) end 调用命令：fastlane buildupload 参数1 参数2 参数3 ... 使用shell修改工程配置 在很多情况下我们使用自动化打包工具都是需要批量处理很多工程编译出不同的IPA包的，这就需要我们在使用fastlane之前先修改一些工程的配置 从svn或者git等仓库里面checkout 代码 12rm -rf deploysvn co svn://xxx/xxx/xxx/xxx deploy 从文件里面读取配置信息到数组如: 123456i=0for s in `cat params/appname.txt`do appnames[$&#123;i&#125;]=$&#123;s&#125; i=$&#123;i&#125;+1 done appname.txt文件里面一行写一个app的名字，有几个app就写几行其他的诸如bundle id ，username 等信息类似 修改应用的bundle Id sed -i &#39;&#39; &quot;s/com.xxx.xxx/$1/g&quot; xxx.xcodeproj/project.pbxproj $1，参数一是新的bundle id 修改应用名称 /usr/libexec/PlistBuddy -c &quot;Set :CFBundleDisplayName $2&quot; Jubaodai/Info.plist $2是新的应用名称 修改应用的icons图片 cp -r ../pictures/$2/AppIcon.appiconset/. xxx/Assets.xcassets/AppIcon.appiconset 修改fastlane 元数据里面的应用名称 echo newAppName &gt; fastlane/metadata/zh-Hans/name.txt 修改fastlane 里面上传iTunes Connect 的icon图片 cp ../pictures/$1/app_icon.jpg fastlane/metadata/app_icon.jpg 调用fastlane 进行自动打包 fastlane buildupload username:${usernames[${i}]} teamid:${teamids[${i}]} appidentifier:${appidentifiers[${i}]} appname:${appnames[${i}]}]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>