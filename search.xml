<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebMagic快速入门]]></title>
    <url>%2F2017%2F06%2F05%2FWebMagic%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[webmagic 是一个优秀的java爬虫工具主要应用场景是对某些页面进行深度爬取。目前在github上已经有4515个Star，用作者的原话来说webmagic的目标是：做一个Java语言Web爬虫的教科书般的实现。本文是一篇快速入门简介，如您想深入了解请点击github上面webmagic仓库链接。 WebMagic的四大组件 Downloaderdownloader 负责从互联网上面下载页面 PageProcessorpageProcssor 负责解析页面获取有用信息，我们主要通过实现PageProcessor的接口来进行定制，获取我们需要的页面信息。 Schedulerscheduler 负责管理待抓取的URL，以及url的去重 Pipelinepipeline 负责处理抽取到的信息，webmagic默认提供了两种实现将信息输出到控制台和保存到本地文件。我们也可以通过实现pipeline的接口来自定义处理抽取结果的方式如，保存到数据库。 WebMagic的使用添加依赖 如果使用maven可在pom文件添加以下字段: 12345678910 &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt;&lt;/dependency&gt; 如果不使用maven可以点击下载jar包后导入工程里面 一个WebMagic的小demo这个demo的目的是爬取起点中文网的一个列表页面 http://a.qidian.com/?chanId=22 从列表页面获取书籍详情的页面的链接，然后在详情页面爬取书籍名称，作者，更新时间和书籍简介 12345678910111213141516171819202122232425262728public class TestPageProcessor implements PageProcessor&#123; //设置站点信息 private Site site = Site.me().setRetryTimes(3).setSleepTime(1000).setTimeOut(10000); @Override public void process(Page page) &#123; if(page.getRequest().getUrl().indexOf(&quot;book.qidian.com/info&quot;) != -1) &#123; //设置捕获规则 page.putField(&quot;bookName&quot;, page.getHtml().css(&quot;div.book-info &quot;).css(&quot;h1&quot;).css(&quot;em&quot;,&quot;text&quot;).toString()); page.putField(&quot;author&quot;, page.getHtml().css(&quot;div.book-info&quot;).xpath(&quot;h1/span/a/text()&quot;).toString()); page.putField(&quot;time&quot;, page.getHtml().css(&quot;div.book-state&quot;).xpath(&quot;li/div/p/em/text()&quot;).toString()); page.putField(&quot;detail&quot;, page.getHtml().css(&quot;div.book-intro&quot;).css(&quot;p&quot;,&quot;text&quot;).toString()); &#125;else &#123; //设置查找路径 page.addTargetRequests(page.getHtml().xpath(&quot;//div[@class=&apos;book-mid-info&apos;]/h4/a&quot;).links().regex(&quot;^*./book.qidian.com/info/\\d&#123;1,&#125;&quot;).all()); &#125; &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) &#123; Spider.create(new TestPageProcessor()).addUrl(&quot;http://a.qidian.com/?chanId=22&quot;).thread(5).run(); &#125;&#125; pageprocessor接口说明 public void process(Page page);可以通过实现这个接口来定义页面的抽取规则如：抽取页面的URL、获取页面标签的文本等等。 public Site getSite();可以通过实现这个接口来对你要抽取的网站进行定制如：设置请求头、超时时间、userAgent等等。对于某些需要登录验证的网站还可以在这里设置网站的cookie值来获取访问权限。在中国移动网站查询通话记录除了需要进行登录还要进行另外一重的身份验证才有查询权限,为site设置cookie值可以很方便的解决这个问题。 爬虫设置 Spider是爬虫启动的入口。在启动爬虫之前，我们需要使用一个PageProcessor创建一个Spider对象，然后使用run()进行启动，可设置开启的线程数和初始爬取的URL。同时也可以设置Spider的其他组件（Downloader、Scheduler、Pipeline）为我们自定义的实现。Spider 1Spider.create(new TestPageProcessor()).addUrl(&quot;http://a.qidian.com/?chanId=22&quot;).thread(5).run(); 在这里我们设置开启5条线程，然后使用run()启动爬虫（run（） 会阻塞当前线程，start()或者runAsync()是异步启动不会阻塞当前线程），默认将爬取结果输出到控制台，如果我们想将结果保存到文件可以这样: 1Spider.create(new TestPageProcessor()).addUrl(&quot;http://a.qidian.com/?chanId=22&quot;).addPipeline(new FilePipeline(&quot;/Users/stone/Desktop/&quot;)).thread(5).run(); 站点设置Site保存了你要爬取的站点信息，同样的你也可以对site进行一些设置。本次爬取就设置了超时时间1000，重试次数3次,休眠实现1000。Site 1private Site site = Site.me().setRetryTimes(3).setSleepTime(1000).setTimeOut(10000); 设置抽取规则 WebMagic提供了一套接口用于页面信息的抽取主要有Css选择器，XPtah，正则匹配这三种方法。另外提供了get(),toString(),all(),match()方法来获取抽取结果。Selectable 对于列表页面我们需要抽取详情页面的链接添加到查找路径里面去： 1page.addTargetRequests(page.getHtml().xpath(&quot;//div[@class=&apos;book-mid-info&apos;]/h4/a&quot;).links().regex(&quot;^*./book.qidian.com/info/\\d&#123;1,&#125;&quot;).all()); 1xpath(&quot;//div[@class=&apos;book-mid-info&apos;]/h4/a&quot;) 上面这条语句使用了Xpath进行抽取，首先查找class是book-mid-info的div标签，然后再查找这个div标签下面的h4子标签，再查找h4标签的子标签a。最终获取a标签下面的所有链接。并对获取到的链接进行正则匹配，并获取所有查到的链接 详情页面书名抽取我们使用Csss进行抽取，将获取到的书籍名称放到bookName标签里面。 1page.putField(&quot;bookName&quot;, page.getHtml().css(&quot;div.book-info &quot;).css(&quot;h1&quot;).css(&quot;em&quot;,&quot;text&quot;).toString()); 上面这条语句使用Css选择器先选中class是book-info的div标签，再在选中结果里面查找div的h1子标签，再从h1子标签里面查找em标签。查到em标签后获取em标签的文本，最终将抽取到的结果转成字符串。 详情页面作者名称抽取我们使用css选择器和xpath结合的方式来抽取作者笔名然后将信息放到author标签里面。 1page.putField(&quot;author&quot;, page.getHtml().css(&quot;div.book-info&quot;).xpath(&quot;h1/span/a/text()&quot;).toString()); 与上面一样首先使用css选择器选择class是book-info的标签，然后再使用Xpath抽取此标签下面的span标签，span标签下面的a标签并且获取a标签的文本，将结果转换成功字符串。 详情页面更新时间和简介的抽取更新时间的获取 1page.putField(&quot;time&quot;, page.getHtml().css(&quot;div.book-state&quot;).xpath(&quot;li/div/p/em/text()&quot;).toString()); 书籍简介的获取 1page.putField(&quot;detail&quot;, page.getHtml().css(&quot;div.book-intro&quot;).css(&quot;p&quot;,&quot;text&quot;).toString()); 爬取结果 PipLine的定制 在实际生产我们一般需要把查询的结果先存储到一个对象中然后再处理这个对象(比如，将对象存储到数据库) 将结果存储到对象我们对协议PageProcessor的接口process进行改写,很简单: 12345678910111213141516 @Overridepublic void process(Page page) &#123; if(page.getRequest().getUrl().indexOf(&quot;book.qidian.com/info&quot;) != -1) &#123; //设置捕获规则 Book book = new Book(); book.setBookName(page.getHtml().css(&quot;div.book-info &quot;).css(&quot;h1&quot;).css(&quot;em&quot;,&quot;text&quot;).toString()); book.setAuthor(page.getHtml().css(&quot;div.book-info&quot;).xpath(&quot;h1/span/a/text()&quot;).toString()); book.setTime(page.getHtml().css(&quot;div.book-state&quot;).xpath(&quot;li/div/p/em/text()&quot;).toString()); book.setDetail(page.getHtml().css(&quot;div.book-intro&quot;).css(&quot;p&quot;,&quot;text&quot;).toString()); page.putField(&quot;book&quot;, book); &#125;else &#123; //设置查找路径 page.addTargetRequests(page.getHtml().xpath(&quot;//div[@class=&apos;book-mid-info&apos;]/h4/a&quot;).links().regex(&quot;^*./book.qidian.com/info/\\d&#123;1,&#125;&quot;).all()); &#125;&#125; 先将捕获的信息存储到对象book中，通过putFidld函数将这个book对象存储到resultItems中。 1234 public void putField(String key, Object field) &#123; resultItems.put(key, field);&#125; 从BookPipline里面获取对象 12345678910 public class BookPipline implements Pipeline &#123; @Override public void process(ResultItems resultItems, Task task) &#123; Book book = (Book)resultItems.get(&quot;book&quot;); if (book != null) &#123; System.out.println(&quot;这些信息可存数据库-&gt;&quot;+book.descript()); &#125; &#125;&#125; 从resultItems里面通过key值book可以直接获取到在PageProcess接口里面存储的对象。 使用自定义的信息处理模块BookPipline 1Spider.create(new TestPageProcessor()).addUrl(&quot;http://a.qidian.com/?chanId=22&quot;).addPipeline(new BookPipline()).thread(5).run(); 在启动爬虫时可以直接使用我们定制的处理模块 ![bookPipline](http://i4.buimg.com/595348/df050f502b0126d7.png) 注解的使用 webmagic除了上面的这种方式还可以提供了注解使用方式，两种方法各有优劣如果业务简单可以使用注解，感兴趣的可以点击注解来了解使用方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS10语音识别]]></title>
    <url>%2F2017%2F05%2F21%2FiOS10%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[iOS10苹果开放了语音识别接口，这让我们可以自己自由的把音频转为文本了。iOS的语音识别主要分为识别音频文件和识别音频缓存（按我的理解就是识别音频输入流达到实时转换的效果）。因为iOS10对权限的要求更严格了所以在一切的工作之前我们要在info.plist文件里面增加两个节点。第一个节点： 1key: Privacy - Speech Recognition Usage Description value:语音识别（这个值可以自定义，需要你描述Speech Recognition的用法） 第二个节点： 1key: Privacy - Microphone Usage Description value:麦克风（这个值也是自定义的，同样是用来描述Microphone的用法的） 下面我们看看怎么识别音频文件：首先我们要请求权限，+ (void)requestAuthorization:(void(^)(SFSpeechRecognizerAuthorizationStatus status))handler这个方法是SFSpeechRecognizer的类方法，SFSpeechRecognizerAuthorizationStatus是个枚举类型表示请求权限的结果，只有当status的值是SFSpeechRecognizerAuthorizationStatusAuthorized时才表示有使用语音识别的权限，增枚举类型的其他三个成员值分别是：用户未决定SFSpeechRecognizerAuthorizationStatusNotDetermined、拒绝SFSpeechRecognizerAuthorizationStatusDenied、不支持SFSpeechRecognizerAuthorizationStatusRestricted看代码： 1234567//请求权限 [SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123; if (status == SFSpeechRecognizerAuthorizationStatusAuthorized) &#123; NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;speech&quot; withExtension:@&quot;m4a&quot;]; [self recognizeAudioFile:url]; &#125; &#125;]; 然后我们再看具体的怎么进行语音识别：SFSpeechRecognizer这个类是具体用来进行语音识别的，默认初始化方法init表示识别本地语言环境，就是说如果你手机是中文那么你说中文就可以直接识别了。当然了如果我们想指定识别某种语言就要使用：- (nullable instancetype)initWithLocale:(NSLocale *)locale 这个方法进行初始化了。然后我们再创建一个SFSpeechURLRecognitionRequest类的实例，这个实例包含了音频信息。最后再调用SFSpeechRecognizer实例的 12- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 方法，将音频信息传给苹果的服务器然后，苹果会直接返回转换后的信息。直接看代码： 12345678910SFSpeechRecognizer *recongize = [[SFSpeechRecognizer alloc] init]; SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url]; [recongize recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 到此为止已经完成了音频文件的识别了。下面我们再说说怎样实时识别音频输入流：识别音频输入流的步骤与上面的大体相似，最主要的不同是音频资源的区别一个是直接从文件获取另外一个是从AVAudioNode的输出数据获取的。所以我们首先要开启麦克风获取AVAudioNode输出的音频信息，这部分就不细说了直接看代码： 123456789101112131415161718192021222324252627282930313233AVAudioSession *session = [AVAudioSession sharedInstance]; NSError *error; [session setCategory:AVAudioSessionCategoryRecord error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setMode:AVAudioSessionModeMeasurement error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; [session setActive:YES withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:&amp;error]; if (error) &#123; self.speechText.text = error.description; return; &#125; if (!auengine.inputNode) &#123; self.speechText.text = @&quot;无输入节点&quot;; return; &#125; [auengine.inputNode installTapOnBus:0 bufferSize:1024 format:[auengine.inputNode outputFormatForBus:0] block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123; if (buffer) &#123; [requestbuffer appendAudioPCMBuffer:buffer]; &#125; &#125;]; [auengine prepare]; [auengine startAndReturnError:&amp;error]; 这样我们在- (void)installTapOnBus:(AVAudioNodeBus)bus bufferSize:(AVAudioFrameCount)bufferSize format:(AVAudioFormat * __nullable)format block:(AVAudioNodeTapBlock)tapBlock这个方法的block里面就可以获取到输出的音频信息，接下来我们再识别这个信息：第一步都是创建一个SFSpeechRecognizer实例，第二步有区别我们要创建SFSpeechAudioBufferRecognitionRequest这个对象的实例，第三步还一样的调用：- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler; 的方法。 看代码： 1234567891011SFSpeechRecognizer *recognize = [[SFSpeechRecognizer alloc] init]; SFSpeechAudioBufferRecognitionRequest *requestbuffer = [[SFSpeechAudioBufferRecognitionRequest alloc] init]; [recognize recognitionTaskWithRequest:requestbuffer resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123; if (result) &#123; self.speechText.text = result.bestTranscription.formattedString; &#125; if (error) &#123; self.speechText.text = error.description; &#125; &#125;]; 完整的源码已经上传到了github,下载源码]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlexBox布局]]></title>
    <url>%2F2017%2F05%2F21%2FFlexBox%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[这段时间熟悉了一下ReactNative，里面的布局感觉很有意思，跟我以前接触的布局思想有很大不同，所以就自己测试了一些FlexBox的属性，一下是效果图：RN的布局主要依赖于FlexBox系统，它有如下几个主要属性：flex 视图的比重，这里注意了：In React Native flex does not work the same way that it does in CSSflexDirection 子视图在容器中排布的方向,这是用来确定主轴的 flexDirection controls which directions children of a container gojustifyContent 子视图在主轴的排列方式 justifyContent aligns children in the main directionalignItems 子视图在主轴的交叉轴（次轴）排列方式 alignItems aligns children in the cross directionalignSelf 子视图在次轴的排列方式，主要是用来重写父视图的alignItemsalignSelf controls how a child aligns in the cross direction, overriding the alignItems of the parent.position 布局方式，默认是相对布局relativeflexWrap 是否包裹 ，默认值是nowrap接下来看代码实现：首先我们也仿照官方的列子写个Circle类来描述作为子视图的球 12345678910111213141516171819class Circle extends Component &#123; render() &#123; var size = this.props.size || 20 var backgroundColor = this.props.backgroundColor || &apos;#dcdcdc&apos; return( &lt;View style=&#123;&#123; borderRadius:size/2, backgroundColor:backgroundColor, width:size, height:size, margin:2, shadowOffset:&#123;width:4,height:4&#125;, shadowColor:&apos;#a9a9a9&apos;, shadowOpacity:0.6 &#125;&#125; /&gt; )&#125;&#125; 其次我们再写个CircleBlock类作为容器，其实就是小球的父视图： 12345678910111213141516171819class Circle extends Component &#123; render() &#123; var size = this.props.size || 20 var backgroundColor = this.props.backgroundColor || &apos;#dcdcdc&apos; return( &lt;View style=&#123;&#123; borderRadius:size/2, backgroundColor:backgroundColor, width:size, height:size, margin:2, shadowOffset:&#123;width:4,height:4&#125;, shadowColor:&apos;#a9a9a9&apos;, shadowOpacity:0.6 &#125;&#125; /&gt; )&#125;&#125; 先看看flexDirection这个属性有哪些值： 123456flexDirection: ReactPropTypes.oneOf([ &apos;row&apos;, //我的理解就是横排 &apos;row-reverse&apos;, //横排颠倒，其实从效果上来看就是把row的一切都反过来 &apos;column&apos;, //竖排 &apos;column-reverse&apos; //竖排颠倒]), 以下几个属性的实际效果： 12345678910111213141516&lt;Text&gt;flexDirection:row&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexDirection:&apos;row&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;flexDirection:column&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexDirection:&apos;column&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;flexDirection:row-reverse&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexDirection:&apos;row-reverse&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;flexDirection:column-reverse&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexDirection:&apos;column-reverse&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt; justifyContent作为子视图在主轴的排列方式有这些值： 1234567justifyContent: ReactPropTypes.oneOf([ &apos;flex-start&apos;, //从开始位置排列，值从左到右或从上到下 &apos;flex-end&apos;, //从结尾位置排列 &apos;center&apos;, //居中 &apos;space-between&apos;, //空间在子视图之间，从效果来看就是子视图等间距 &apos;space-around&apos; //空间环绕子视图，我的理解是每个子视图占据相同的空白 ]), 看代码： 1234567891011121314151617181920&lt;Text&gt;justifyContent:flex-start&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;justifyContent:&apos;flex-start&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;justifyContent:center&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;justifyContent:&apos;center&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;justifyContent:flex-end&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;justifyContent:&apos;flex-end&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;justifyContent:space-between&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;justifyContent:&apos;space-between&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;Text&gt;justifyContent:space-around&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;justifyContent:&apos;space-around&apos;&#125;&#125;&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt; 至于效果，是这样的 alignItems是子视图在主轴交叉轴的排列方式，有这些值 123456alignItems: ReactPropTypes.oneOf([ &apos;flex-start&apos;, //从开始位置排列 &apos;flex-end&apos;, //从结尾处排列 &apos;center&apos;, //居中 &apos;stretch&apos; //拉伸 ]), alignSelf做为对alignItems的重写，值与alignItems一样 123456789101112&lt;Text&gt;alignItems: flex-start&lt;/Text&gt; &lt;CircleBlock style=&#123;&#123;alignItems:&apos;flex-start&apos;,height:100&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &lt;Text&gt; alignItems:center&lt;/Text&gt; &lt;CircleBlock style=&#123;&#123;alignItems:&apos;center&apos;,height:100&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &lt;Text&gt;alignItems:flex-end&lt;/Text&gt; &lt;CircleBlock style=&#123;&#123;alignItems:&apos;flex-end&apos;,height:100&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; flexWrap包裹 1234flexWrap: ReactPropTypes.oneOf([ &apos;wrap&apos;, //子视图超过一行的长度后将会换行 &apos;nowrap&apos; //子视图超过一行的长度后不换行 ]), 下面是代码:1234567891011121314151617181920212223&lt;Text&gt;flexWrap:wrap&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexWrap:&apos;wrap&apos;,height:150&#125;&#125;&gt; &#123;[minCircles,minCircles,minCircles,minCircles,minCircles,minCircles]&#125;&lt;/CircleBlock&gt;&lt;Text&gt;flexWrap:nowrap&lt;/Text&gt;&lt;CircleBlock style=&#123;&#123;flexWrap:&apos;nowrap&apos;,height:150&#125;&#125;&gt; &#123;minCircles&#125; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,marginVertical:40&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt;&lt;/CircleBlock&gt;&lt;CircleBlock style=&#123;&#123;flexWrap:&apos;wrap&apos;,height:150&#125;&#125;&gt; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,position:&apos;absolute&apos;,marginVertical:40&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &#123;minCircles&#125;&lt;/CircleBlock&gt;&lt;CircleBlock style=&#123;&#123;flexWrap:&apos;nowrap&apos;,height:150&#125;&#125;&gt; &#123;minCircles&#125; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,alignSelf:&apos;center&apos;&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt;&lt;/CircleBlock&gt; position当子视图需要在父视图里面精准定位是需要将子视图的position设置为absoulute 1234position: ReactPropTypes.oneOf([ &apos;absolute&apos;, //相对布局 &apos;relative&apos; //绝对布局 ]), 而且是这里面的绝对布局可以理解是对容器剩余空间的布局，要注意区分这段代码的实现和效果：实现123456789101112131415161718&lt;CircleBlock style=&#123;&#123;height:150&#125;&#125;&gt; &#123;minCircles&#125; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,marginVertical:40&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &lt;/CircleBlock&gt; &lt;CircleBlock style=&#123;&#123;height:150&#125;&#125;&gt; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,position:&apos;absolute&apos;,marginVertical:40&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &lt;CircleBlock style=&#123;&#123;height:150&#125;&#125;&gt; &#123;minCircles&#125; &lt;CircleBlock style=&#123;&#123;width:100,flexWrap:&apos;wrap&apos;,alignSelf:&apos;center&apos;&#125;&#125;&gt; &#123;minCircles&#125; &lt;/CircleBlock&gt; &lt;/CircleBlock&gt; 效果： 源码已上传到git上面了，下载源码]]></content>
  </entry>
  <entry>
    <title><![CDATA[RN与iOS通讯]]></title>
    <url>%2F2017%2F05%2F21%2FRN%E4%B8%8EiOS%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[RN可以很好的与原生进行交互，我们首先看看效果吧： 首先我们来看看React Native 怎样调用iOS的代码并且带有简单的参数：在iOS工程里面我们新建一个类iOSExport，iOSExport将会实现RCTBridgeModule协议。首先我们要在iOSExport类的实现中添加这句宏定义：RCT_EXPORT_MODULE()RCT_EXPORT_MODULE()如果你不传入参数，那么你在iOS中导出的模块名就是类名，你也可以插入参数作为自定义模块名。 1234@implementation iOSExport//定义导出的模块名RCT_EXPORT_MODULE()@end 后面我们就可以实现协议的代理方法了，协议方法的实现需要在RCT_EXPORT_METHOD，这个宏里面。我们先写一个有两个参数的方法给js调用： 1234567891011@implementation iOSExport//定义导出的模块名RCT_EXPORT_MODULE()//定义导出的方法名RCT_EXPORT_METHOD(rnToiOS:(NSString *)name :(NSInteger)age) &#123; NSString *st = [NSString stringWithFormat:@&quot;name:%@,age:%ld&quot;,name,age]; NSLog(@&quot;test:%@&quot;,st); [self alter:st];&#125;@end 这样OC端的工作就OK了，下面我们继续看看js端怎么调用：首先我们要在js文件里面 import NativeModules然后在我们需要使用的时候获取导出的模块，我们再用模块调用iOS的导出的函数名就可以了，看代码： 1234567891011121314151617//创建一个可以点击的按钮，点击按钮后调用iOS的rnToiOS方法&lt;TouchableHighlight style=&#123;[styles.highLight,&#123;marginTop:50&#125;]&#125; underlayColor=&apos;#deb887&apos; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; this._nameAndAge()&#125; &gt; &lt;Text&gt;简单数据传递&lt;/Text&gt;&lt;/TouchableHighlight&gt;_nameAndAge() &#123; //多参数的传递 var iOSExport = NativeModules.iOSExport //获取到模块 iOSExport.rnToiOS(&apos;帝君&apos;,200) //直接调用函数 this.setState(&#123; text:&apos;rnToiOS&apos; &#125;)&#125; 下面我们再看如何在js端调用iOS的含有字典参数和回调函数的方法。iOS提供给js的回调函数是使用block实现的，看下回调函数的说明： 12345/** * The type of a block that is capable of sending a response to a bridged * operation. Use this for returning callback methods to JS. */typedef void (^RCTResponseSenderBlock)(NSArray *response); 下面我们就可以用回调函数做参数，写一个我们需要的方法： 123456789RCT_EXPORT_METHOD(rnToiOSwithDic:(NSDictionary*)dic andCallback:(RCTResponseSenderBlock)callback) &#123; NSMutableString *st = [NSMutableString string]; for (NSObject *key in dic.allKeys) &#123; NSString *string = [NSString stringWithFormat:@&quot;%@:%@;&quot;,key,[dic objectForKey:key]]; [st appendString:string]; &#125; callback(@[@&quot;error&quot;,st]); [self alter:st];&#125; 最终我们的回调函数给js的是一个数组，一般这个数组的第一个元素表示的都是错误。看下如何在js端调用这个方法: 123456789101112131415161718192021222324252627//为了测试方便我们先写个按钮&lt;TouchableHighlight style=&#123;styles.highLight&#125; underlayColor=&apos;coral&apos; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; this._dic()&#125; &gt; &lt;Text&gt;字典的传递和回调&lt;/Text&gt;&lt;/TouchableHighlight&gt;//字典的传递和返回值 _dic() &#123; var iOSExport = NativeModules.iOSExport //获取导出的模块 iOSExport.rnToiOSwithDic(&#123; //调用iOS的方法，第一个参数是字典 &apos;姓名&apos;:&apos;幽冥&apos;, &apos;年龄&apos;:20, &apos;法力&apos;:&apos;200&apos; &#125;,(error,strings) =&gt;&#123; //第二个参数是函数，做为回调函数给iOS将由iOS调用 this.setState(&#123; text:strings &#125;) &#125;) this.setState(&#123; text:&apos;rnToiOSwithDic&apos; &#125;) &#125; 上面对于回调函数的处理稍显麻烦，我们再看使用promise实现的回调函数：我们先看下iOS里面的两个block: 123456789101112/** * Block that bridge modules use to resolve the JS promise waiting for a result. * Nil results are supported and are converted to JS&apos;s undefined value. */typedef void (^RCTPromiseResolveBlock)(id result);/** * Block that bridge modules use to reject the JS promise waiting for a result. * The error may be nil but it is preferable to pass an NSError object for more * precise error messages. */typedef void (^RCTPromiseRejectBlock)(NSString *code, NSString *message, NSError *error); 这两个block其实就是实现promise回调的关键，一个是成功的回调一个是失败的回调，看下iOS端的实现： 1234567RCT_EXPORT_METHOD(rnToiOSAge:(NSInteger)age resolve:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) &#123; if (age &gt; 23) &#123; resolve(@[@&quot;句芒&quot;]); &#125;else &#123; reject(@&quot;101&quot;,@&quot;年龄错误&quot;,[NSError errorWithDomain:@&quot;错误&quot; code:1 userInfo:nil]); &#125;&#125; 在js里面我要调用这个方法其实只要传一个参数age就可以了，后面两个参数可能会转换为promis作为返回值处理，看下js端是怎么调用的： 123456789101112131415161718192021//作为测试的按钮&lt;TouchableHighlight style=&#123;styles.highLight&#125; underlayColor=&apos;#5f9ea0&apos; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; this._promise(30)&#125; &gt; &lt;Text&gt;Promise回调&lt;/Text&gt;&lt;/TouchableHighlight&gt;//按钮的回调事件，将在这里调用iOS的方法async _promise(age) &#123; //Promise回调,异步执行 try&#123; var iOSExport = NativeModules.iOSExport var resolve = await iOSExport.rnToiOSAge(age) //执行iOS函数并且等待结果 this.setState(&#123; text:resolve &#125;) &#125;catch(e) &#123; console.error(e); &#125;&#125; 这里要说下，因为我们是采用promsie返回值的方式处理回调的，所以我们不知道何时将返回结果，所以按钮的点击函数_promise(age)前面要加个async关键字标识为异步函数，我们在函数里面可以使用try{}catch(){}来捕获异常，因为我们明确的知道如果age小于24就将报错，所以我们在这里一定要添加异常处理。注意了在执行iOS函数的时候也要加await关键字的，等待获取到返回值后再执行下面的操作。在iOS里面也可以很方便地给js注入常量，采用如下方法可以方便的提供常量： 12345678/** * Injects constants into JS. These constants are made accessible via * NativeModules.ModuleName.X. It is only called once for the lifetime of the * bridge, so it is not suitable for returning dynamic values, but may be used * for long-lived values such as session keys, that are regenerated only as * part of a reload of the entire React application. */- (NSDictionary&lt;NSString *, id&gt; *)constantsToExport; 这里要注意了，这函数只会在桥接的过程中执行一次，所以不太适合变量的传递，iOS里面的实现： 1234//为js提供静态数据- (NSDictionary&lt;NSString *,id&gt; *)constantsToExport &#123; return @&#123;@&quot;name&quot;:@&quot;闲&quot;,@&quot;age&quot;:@&quot;22&quot;&#125;;&#125; js如何调用的： 123456789101112131415&lt;TouchableHighlight style=&#123;styles.highLight&#125; underlayColor=&apos;#5f9ea0&apos; activeOpacity=&#123;0.8&#125; onPress=&#123;() =&gt; this._getConst()&#125; &gt; &lt;Text&gt;获取iOS常量&lt;/Text&gt;&lt;/TouchableHighlight&gt;_getConst() &#123; var iOSExport = NativeModules.iOSExport //获取模块 this.setState(&#123; text:iOSExport.name+&apos;,&apos;+iOSExport.age //获取常量 &#125;) &#125; 在上面这些函数里面如果我想统一指定他们在什么线程里执行的，只要实现这函数就可以了： 1234//告诉程序这个模块的代码在哪个线程执行- (dispatch_queue_t)methodQueue &#123; return dispatch_get_main_queue(); //返回一个指定的线程&#125; 前面说了那么多都是怎么在js里面调用iOS的方法的，那么如何让iOS主动发送消息给js呢。首先我们更改一下iOSExport这个类，让它继承自RCTEventEmitter，并且删除协议，因为RCTEventEmitter这个类也会实现RCTBridgeModule协议的： 123//继承自RCTEventEmitter的OC类将有资格给js发送消息@interface iOSExport :RCTEventEmitter@end 然后在iOSExport的实现里面我们还要重写一个方法，用来指定这模块将会发送哪些消息给js : 123- (NSArray&lt;NSString *&gt; *)supportedEvents &#123; return @[@&quot;sendName&quot;]; //这里返回的将是你要发送的消息名的数组。&#125; 然后我们就可以直接发送消息了： 123456789- (void)alter:(NSString *)st &#123; UIAlertController *alter = [UIAlertController alertControllerWithTitle:@&quot;测试&quot; message:st preferredStyle:UIAlertControllerStyleAlert]; [alter addAction:[UIAlertAction actionWithTitle:@&quot;了解&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; //iOS发送通知给js [self sendEventWithName:@&quot;sendName&quot; body:@&#123;@&quot;name&quot;:@&quot;江山&quot;,@&quot;age&quot;:@&quot;5000&quot;&#125;]; &#125;]]; [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:alter animated:YES completion:nil];&#125; 我们使用- (void)sendEventWithName:(NSString *)eventName body:(id)body 发送消息，eventName将是消息的名字，body可以传个字典作为消息体。那么如何在js里面接受消息呢：首先要import NativeEventEmitter，然后我们注册监听事件： 123456789101112 componentWillMount() &#123; //开始监听 var iOSExport = NativeModules.iOSExport var emitter = new NativeEventEmitter(iOSExport) //用获取的模块创建监听器 this.subScription = emitter.addListener(&quot;sendName&quot;,(body) =&gt; this._getNotice(body)) //监听指定的事件，通过sendName这事件名来识别事件，(body) =&gt; this._getNotice(body)这是监听到事件后的处理方法，body 是iOS传过来的消息体&#125;_getNotice (body) &#123; this.setState(&#123; notice:body.name+&apos;,&apos;+body.age &#125;)&#125; 最后我们要注销监听： 1234componentWillUnmount() &#123; //删除监听 this.subScription.remove()&#125; 以上源码都已经上传gitub，源码下载]]></content>
      <tags>
        <tag>RN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6语法整理]]></title>
    <url>%2F2017%2F05%2F21%2FES6%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于Let Var 1、let不会发生变量的提升，Var会发生变量提升 2、Let是块级作用域 3、暂时性死区 关于箭头函数 1、箭头函数的初识 2、箭头函数绑定this 异步相关 1、Promise对象可以用来表示一个异步操作 2、async - await 简化异步操作写法 2.1最后我们模仿一下fetch以便加深你的印象]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS获取通讯录]]></title>
    <url>%2F2017%2F05%2F21%2FiOS%E8%8E%B7%E5%8F%96%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[##获取通讯录有的时候我们需要获取用户的通讯录信息上传给服务器，对于iOS来说iOS9之前和之后有不同的方法用于获取通讯录信息。 iOS9之前在9之前的版本获取通讯录信息是通过ABAddressBookCopyArrayOfAllPeople 来获取所有联系人的信息的。所有的联系人信息被保存在一个数组里面，我们只需要遍历整个数组就可以获取我们想要的信息的。下面以获取所有联系人的姓名和电话号码和唯一识别码为例，提供一个简单的函数： 12345678910111213141516171819202122232425262728293031323334- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125; iOS9之后在iOS9之后，苹果为方便获取通讯录提供了一套API,开发者可以通过CNContactStore 这个类获取需要的信息,这个类有个实例方法:enumerateContactsWithFetchRequest: error:usingBlock: ,每获取到一个联系人信息这个方法的回调函数就会执行一次。 This method waits until the enumeration is finished. If there are no results, the block is not called and the method returns YES.This can be used to fetch all contacts without keeping all of them at once in memory because this is expensive. 上面是苹果开发文档里面的一段话，这个方法是同步的阻塞当前线程。所以我们可以很方便地获取所有的联系人信息。下面是在iOS9以后获取所有联系人的姓名电话号码和唯一身份识别码的一个方法:12345678910111213141516171819202122232425262728293031- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125; 当然了事情到这里还没有结束，在获取通讯录之前我们需要用户授权。 获取用户授权获取用户授权主要思路是每次访问通讯录之前会检查授权情况如果已经授权直接访问通讯录，如果拒绝授权给出提示跳转应用设置页面引导用户打开授权，如果未授权则发起授权请求。问题比较简单就不加赘述，直接看代码: iOS9之前12345678910111213141516171819202122- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125; iOS9之后123456789101112131415161718192021222324- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125; 完整代码下面是封装的一个获取手机通讯录的类 123456789#import &lt;Foundation/Foundation.h&gt;#import &lt;Contacts/Contacts.h&gt;#import &lt;UIKit/UIKit.h&gt;#import &lt;AddressBook/AddressBook.h&gt;#import &quot;UIViewController+Tools.h&quot;#import &quot;FWDefine.h&quot;@interface FWAddressBook : NSObject- (void)accessAddressBook:(void(^)(NSArray *))completionHandler;@end ———————————123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#import &quot;FWAddressBook.h&quot;@implementation FWAddressBook- (void)accessAddressBook:(void(^)(NSArray * models))completionHandler &#123; if ([self terminate]) return; if (Before9) &#123; [self accessAddressBookBefore9:completionHandler]; &#125;else &#123; [self accessAddressBookLater9:completionHandler]; &#125;&#125;- (void)accessAddressBookLater9:(void(^)(NSArray * models))completionHandler &#123; CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; CNContactStore *store = [[CNContactStore alloc] init]; if (status == CNAuthorizationStatusAuthorized) &#123; [self accessContacts:store andResult:completionHandler]; return; &#125; if (status == CNAuthorizationStatusNotDetermined) &#123; [store requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; [self accessContacts:store andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;]; return; &#125; if (status == CNAuthorizationStatusDenied) &#123; [self alert]; &#125;&#125;- (void)accessAddressBookBefore9:(void(^)(NSArray * models))completionHandler &#123; ABAuthorizationStatus status = ABAddressBookGetAuthorizationStatus(); ABAddressBookRef addressBookRef = ABAddressBookCreate(); if (status == kABAuthorizationStatusAuthorized) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else if (status == kABAuthorizationStatusNotDetermined) &#123; ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef error) &#123; if (granted) &#123; [self accessABAddressBook:addressBookRef andResult:completionHandler]; &#125;else &#123; [self alert]; &#125; &#125;); &#125;else if (status == kABAuthorizationStatusDenied) &#123; [self alert]; &#125; if (addressBookRef) &#123; CFRelease(addressBookRef); &#125;&#125;- (void)accessABAddressBook:(ABAddressBookRef)addressBookRef andResult:(void(^)(NSArray * models))completionHandler &#123; CFArrayRef arrayRef = ABAddressBookCopyArrayOfAllPeople(addressBookRef); NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; for (int i = 0; i&lt; CFArrayGetCount(arrayRef); i++) &#123; ABRecordRef people = CFArrayGetValueAtIndex(arrayRef, i); NSString *identify = [NSString stringWithFormat:@&quot;%d&quot;,ABRecordGetRecordID(people)]; NSString *firstName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonFirstNameProperty)); NSString *lastName = (__bridge NSString *)(ABRecordCopyValue(people, kABPersonLastNameProperty)); NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; ABMutableMultiValueRef phonesArray = ABRecordCopyValue(people, kABPersonPhoneProperty); NSString *phoneNumber = @&quot;&quot;; for (int j = 0; j &lt; ABMultiValueGetCount(phonesArray); j++) &#123; NSString *phone = (__bridge NSString *)(ABMultiValueCopyValueAtIndex(phonesArray, j)); if (phone) &#123; phone = [phone stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:phone]; &#125; &#125; if([phoneNumber isEqualToString:@&quot;&quot;]) &#123; continue; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125; completionHandler([mutableArray copy]);&#125;- (void)accessContacts:(CNContactStore *)store andResult:(void(^)(NSArray * models))completionHandler&#123; CNContactFetchRequest *request = [[CNContactFetchRequest alloc] initWithKeysToFetch:@[CNContactGivenNameKey,CNContactFamilyNameKey,CNContactPhoneNumbersKey]]; NSMutableArray *mutableArray = [[NSMutableArray alloc] init]; [store enumerateContactsWithFetchRequest:request error:nil usingBlock:^(CNContact * _Nonnull contact, BOOL * _Nonnull stop) &#123; NSString *firstName = contact.familyName; NSString *lastName = contact.givenName; NSString *identify = contact.identifier; NSString *name = [[NSString alloc] init]; if (firstName) &#123; name = [name stringByAppendingString:firstName]; &#125; if (lastName) &#123; name = [name stringByAppendingString:lastName]; &#125; NSString *phoneNumber = @&quot;&quot;; for (CNLabeledValue&lt;CNPhoneNumber*&gt; *phone in contact.phoneNumbers) &#123; NSString *number = phone.value.stringValue; if (number) &#123; number = [number stringByAppendingString:@&quot;;&quot;]; phoneNumber = [phoneNumber stringByAppendingString:number]; &#125; &#125; if ([phoneNumber isEqualToString:@&quot;&quot;]) &#123; return ; &#125; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:name,@&quot;desc&quot;,phoneNumber,@&quot;phoneNo&quot;,identify,@&quot;deviceRecordId&quot;, nil]; [mutableArray addObject:dic]; &#125;]; completionHandler([mutableArray copy]);&#125;- (void)alert &#123; UIViewController *controller = [UIApplication sharedApplication].keyWindow.rootViewController; [controller alertSure:^&#123; NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url options:@&#123;&#125; completionHandler:nil]; &#125; message:@&quot;为了成功贷款，请您前往设置页面允许应用访问通讯录&quot;];&#125;- (BOOL)terminate &#123; NSDate *date = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;time&quot;]; NSDate *currentDate = [NSDate date]; if (date) &#123; NSTimeInterval time = [currentDate timeIntervalSinceDate:date]; if (time &lt; 24*60*60) return YES; [self saveTime:currentDate]; &#125;else &#123; [self saveTime:currentDate]; &#125; return NO;&#125;- (void)saveTime:(NSDate *)time &#123; [[NSUserDefaults standardUserDefaults] setObject:time forKey:@&quot;time&quot;]; [[NSUserDefaults standardUserDefaults] synchronize];&#125;@end]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift构造过程1]]></title>
    <url>%2F2017%2F05%2F21%2FSwift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[Swift 的类、结构体、枚举构造完成后它们的所有存储属性一定有一个值 存储属性可以在声明的时候直接给定一个默认值或者在构造的时候赋值,可选属性在初始化的时候会被赋值nil 构造器的语法自定义外部参数名称123456789101112struct Counter &#123; let max : Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125;&#125; 我们定义一个结构体Counter,并提供一个构造器init(maxValue a : Int,minValue b:Int) 类似于函数这个构造器我们可以指定外部参数名称(maxValue,minValue)用于区分不同的构造器。 对于存储属性我们既可以在声明的时候给定默认值也可以在构造的过程中重新设置，如在上面的构造过程中只有当b&lt;0时才对min赋值。对于常量属性我们可以在构造的过程中赋值(没有默认值的情况) 对于可选属性如果我们在构造的过程中没有给它赋值，它将自动获得一个值nil 上面的构造器可以这样调用：var a = Counter(maxValue: 100, minValue:0) 默认外部参数名称123456789101112131415161718struct Counter &#123; let max:Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125; //默认外部参数名称 init(max:Int) &#123; self.max = max min = 0 &#125;&#125; 构造器init(max:Int) 我们并没有显示声明函数外部名称它将自动获得一个与内部名称一样的外部名称 在构造器里面我们可以使用属性名直接引用属性，但是如果构造器的内部参数名称与属性名重名可以使用self.propertyName这个格式来引用属性 上面的构造器可以这样调用:var b = Counter(max: 50) 忽略外部参数名称123456789101112131415161718192021222324252627struct Counter &#123; let max:Int var min = 9 var current:Int? //自定义外部名称 init(maxValue a : Int,minValue b:Int) &#123; max = a if b &lt; 0 &#123; min = b &#125; &#125; //默认外部参数名称 init(max:Int) &#123; self.max = max min = 0 &#125; //忽略外部参数名称 init(_ a:Int,_ b:Int) &#123; //值类型的构造器代理(枚举和结构体) if a &gt; b &#123; self.init(maxValue: a, minValue: b) &#125;else &#123; self.init(maxValue: b, minValue: a) &#125; &#125; &#125; 如果我们不想使用外部参数名称可以用_表示忽略 对于值类型来说在一个构造器中可以直接代理它本身的其他构造器来完成一部分构造过程 上面的构造器可以这样调用:var c = Counter(20,100) 默认构造器 如果结构体和类所有的属性都有默认值它们将自动获得一个默认构造器 12345class Person &#123; var givenName = "仙贝" var lastName = "落霞" var age:Int?&#125; 对于类（也可以是结构体）来说,如果它的所有属性都有存在一个默认值它将自动获得一个默认构造器，你可以使用默认构造器来初始化这个类:var f = Person() 结构体的逐一成员构造器1234567struct Color &#123; //如果结构体或者类所有的属性都都有默认值，它将自动获得一个默认构造器 //如果结构体没有自定义构造器它将自动获得逐一成员构造器（常量属性除外） var r = 124 let g = 255 var b:Int?&#125; 如果结构体没有自定义构造器它将获得一个逐一成员构造器，对于上面的结构体Color你可以通过两种方法初始化： 通过默认构造器var d = Color() 通过结构体逐一成员构造器 var e = Color(r: 255, b: 244) ##END下一篇 我们将说说类的构造]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift构造过程2]]></title>
    <url>%2F2017%2F05%2F21%2FSwift%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[Swift中类的构造过程分为两个阶段 每个存储属性在它们被引入的类中会被指定一个初始值当所有的存储属性都有一个初始值后第二阶段开始。 在新实例使用之前，允许每个类进一步定制它们的存储属性。 类的代理规则 子类中的指定构造器必须调用父类的指定构造器(如果本身是父类可以忽略这条) 一个类的便利构造器必须调用这个类的其他构造器（横向代理） 一个类的便利构造器必须最终调用这个类的指定构造器(向上代理) 类的指定构造器父类的指定构造器1234567891011121314class Book &#123; var boonName:String var bookPrice:Double var sendFriend:String &#123; get &#123; return boonName &#125; &#125; //指定构造器 init(name:String,price:Double) &#123; boonName = name; bookPrice = price &#125;&#125; 指定构造器的语法跟值类型构造器的语法相同 我们可以直接使用指定构造器来初始化一个实例如:var book3 = Book(name: &quot;Like&quot;, price: 99) 子类的指定构造器1234567891011class MyBook:Book &#123; var publicationDate:String //指定构造器 init(name:String,price:Double,date:String) &#123; publicationDate = date //规则1，指定构造器必须调用父类中的指定构造器 super.init(name: name, price: price) bookPrice = 100 &#125;&#125; MyBook这个类继承自Book，对于子类的指定构造器有如下需要注意的： 在子类的指定构造器中必须先给新引入的属性赋值 子类中的指定构造器必须代理父类中指定构造器super.init(...) 子类中指定构造器必须在代理父类中的指定构造器后再设置继承来的属性值，在之前设置继承的属性值会在调用父类的指定构造器过程中被覆盖的。 我们可以用MyBook的指定构造器初始化:var myBook5 = MyBook(name: &quot;Five&quot;, price: 9.9, date: &quot;1992&quot;) 类的便利构造器对于Book这个类我们新增两个便利构造器1234567convenience init(freeBookName:String) &#123; self.init(name: freeBookName, price: 0)&#125;convenience init() &#123; self.init(freeBookName:&quot;Love China&quot;)&#125; 对于MyBook这个类新增两个便利构造器12345678910convenience init(myBookName:String,price:Double) &#123; self.init(name: myBookName, price: price, date: &quot;today&quot;) if bookPrice &gt; 50 &#123; self.bookPrice = 50 &#125;&#125;convenience override init(name: String, price: Double) &#123; self.init(myBookName: name, price: price) self.publicationDate = &quot;2017&quot;&#125; 对于便利构造器我们有一下几点: 便利构造器必须先代理类中的其他构造器 便利构造器必须最终代理到指定构造器 在便利构造器必须先代理其他构造器再修改属性值 在构造器的第一阶段完成前是无法使用self，无法调用实例方法。 在便利构造器中我们必须在代理其他构造器后才可以是有self,实例方法 我们可以通过便利构造器来初始化一个实例:var myBook3 = MyBook(name: &quot;World&quot;, price: 22),其用法与指定构造器一样 类的可失败构造器 对于Book这个类新增一个可失败构造器 12345init?(highPrice:Double) &#123; if highPrice &lt; 100 &#123; return nil &#125; self.boonName = &quot;Price&quot; self.bookPrice = highPrice&#125; 可失败构造器的语法跟指定构造器的区别是在init后多了一个? 可失败构造器是指在构造过程当不满足某些条件时返回nil值,在使用可失败构造器初始化实例时返回的是一个可选 如果在子类的非可失败构造器中向上代理到父类的可失败构造器，那么需要对父类的可失败构造器的代理结果强制解包 我们可以这样来使用一个可失败构造器: 123456if var book4 = Book(highPrice: 55) &#123; book4.bookPrice book4.boonName&#125;else &#123; var book5 = Book(highPrice: 120)&#125; 类的必要构造器对于Book这个类，新增一个必要构造器1234required init (lowPrice:Double) &#123; boonName = &quot;Run&quot; bookPrice = lowPrice &#125; 必要构造器需要在构造器前面添加关键字 required 必要构造器要求子类也要重写这个构造器，并且子类重写的构造器也要添加关键字required 类的继承与重写类的继承Swift里面的类不会像OC里面子类会自动继承父类的构造方法，必须要满足一定条件子类才会继承父类的构造方法 当满足前提：子类中新引入的属性都有默认值时有下面的规则适用: 如果子类没有提供自己的指定构造器那么它将自动继承父类的指定构造器 - 如果子类有提供所有父类的指定构造器的实现（可以是通过满足前面条件继承来的也可以是在子类中重写的），那么子类将默认继承父类的便利构造器 类的重写子类可以对父类的构造器进行重写，对于重写有如下的一些总结： 如果父类有必要构造器，子类必须重写父类的必要构造器 子类可以将父类的指定构造器重写成子类的指定构造器，在构造器前加关键字override 子类可以将父类的指定构造器重写成为子类的便利构造器，在构造器前加关键字convenience override 子类严格意义来说是无法重写父类的便利构造的，但是可以在子类中指定一个跟父类的便利构造器一下的构造器实现，这个构造器可以是子类的便利构造器也可以是子类的指定构造器，无论是哪种都不要有override关键字]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppStore账号申请]]></title>
    <url>%2F2017%2F05%2F20%2FAppStore%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[1.申请Apple ID1.1 请点击进入苹果开发者网站1.2 进入网页后点击右上角的Account标签进入新页面，点击创建App ID1.3 填写信息创建Apple ID2.申请邓白氏码2.1 请点击进入苹果开发者网站2.2 点击网页上方的Support标签，进入新页面点击Membership 2.3 选择邓白氏编码 D-U-N-S Number点击 2.4 点击D-U-N-S Number look up tool 连接在收到邓白氏码后请求公司账号的时候请注意时间问题 Receiving and Managing Your D-U-N-S NumberAfter requesting a D-U-N-S Number, please allow up to 5 business days to receive your number from D&amp;B. Expediting your D-U-N-S Number creation process will not shorten this waiting period. If your application has taken longer than two weeks to process, please email D&amp;B.Once you receive your D-U-N-S Number, please allow up to 2 business days for Apple to receive your information from D&amp;B. After this period, you may enroll as a company/organization in the Apple Developer Program.To update your D&amp;B profile, please email D&amp;B. It takes up to 14 business days for D&amp;B to provide updated information to Apple. 在点击后如果你没有登录苹果开发者网站系统会让你登陆，请用第一步申请到的Apple ID和密码进行登陆。 2.5 填写公司信息公司信息填写完成后点击右下角的Continue,进入下一页面。如果你的公司没有邓白氏编码你可以请求一个邓白氏编码。 2.6 请求公司的邓白氏编码提交申请后请注册查看来自邓白氏公司的邮件。在请求邓白氏编码的时候会接受到来自邓白氏的邮件和回访电话，在此期间按照要求提供材料就可以了,在此期间你需要的是耐心等待 3.注册成为苹果公司开发者3.1 点击进入苹果官网 点击右上角蓝色的Enroll按钮进入下一页。后继续点击页面下方蓝色的按钮:Start Your Enrollment 3.2 选择成为公司开发者 3.3 填写申请信息 3.4 校验信息提交申请]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化发布工具fastlane]]></title>
    <url>%2F2017%2F05%2F19%2FiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83%E5%B7%A5%E5%85%B7fastlane%2F</url>
    <content type="text"><![CDATA[fastlane初识 fastlane 是一个很棒的iOS和Andriod的一个自动化版本发布工具，它提供了一系列的插件用来解决打包发布上传应用市场这个过程一系列的问题。本教程将介绍如何通过fastlane来自动化上传一个应用到AppStore fastlane环境搭建 在一切开始之前你需要确定你的电脑上有最新的Xcode命令行工具在终端输入：xcode-select --install 安装fastlane:你有三种方式在你的电脑上安装fastlane 使用命令行brew cask install fastlane 通过homewbrew软件包管理器安装 使用命令行sudo gem install fastlane -NV 通过gem安装 如果你使用上面的命令行安装出错了，那么你可以直接点击连接下载安装包来安装fastlane 初始化:进入你app的根目录下执行命令行 fastlane init 至此你将可以通过fastlane来管理你项目的发布过程。 fastlane的常用插件produce Creates the given application on iTC and the Dev Portal if necessaryproduce插件是用来在iTunes Connect里面创建你自己的应用的（如果有则不创建） procuce有很多可选参数，下面简单介绍几个: username 用户名，这个就是你的appid账号 team_id 团队id，这个是你所在团队的id app_identifier 你应用的唯一标识符,可以填bundle Id app_name 你应用的名称 language 应用支持的语言，简体中文：Simplified Chinese app_version app的版本号 1.0 sku 套装id，简单点直接写bundle Id 1234567891011lane :createApp do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier] )end 我们可以使用lane 定义一个代码块用来封装我们需要的功能，同时可以使用options来配置参数 更多可用参数请点击这里More cert Fetch or generate the latest available code signing identity cret插件可以用来获取最新的代码签名证书,官方推荐配合match插件使用（如果你需要进行团队合作） 介绍几个cert的可选参数: username 用户名，你的苹果开发者账号 team_id 团队的Id 1234cert( username: options[:username], team_id: options[:teamid] ) 更多可用的参数请点击这里More pem Makes sure a valid push profile is active and creates a new one if neededpem 插件是用来创建iOS推送证书的，它会先确定是否有一个可用的推送证书如果有需要会创建一个新的推送证书 可选参数: username 用户名，就是你的开发者账号 team_id 团队的Id p12_password 用于p12文件的密码 generate_p12 创建一个p12文件 output_path 导出的证书钥匙串等的存放目录 12345678pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) 更多可用的参数请点击这里More sigh Generates a provisioning profile. Stores the profile in the current folder .sigh 是用来创建配置文件provisioning的如果需要进行团队合作建议配合match插件使用sigh 可选参数: force 是否更新配置文件 app_identifier app的唯一标识符 bundleId id username 用户名，你的苹果开发者账号 team_id 团队的Id 123456sigh( force: true, username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier] ) 更多可用的参数请点击这里More gym Easily build and sign your app using gymgym插件可以对你的项目进行编译打包并且进行签名 可用的参数: scheme 待编译工程的schem，可以使用命令行xcodebuild -list来获取可用的schem值 clean 是否在编译之前清理工程 silent 是否隐藏不必要信息 output_directory 编译好的ipa包的存放目录 1234gym( silent: true, clean: true ) 更多可用的参数请点击这里More snapshot Generate new localised screenshots on multiple devices自动截图工具，可以对应用截图自动生成iTunes Connect需要的预览图片 可用参数: devices 截图时使用的机器 languages 使用的语言 output_directory 生成图片的导出目录 当然了，你可以使用命令fastlane snapshot init 来自动生成截图需要的配置，在自动生成的Snapfile文件里面会有一些提供好的参数可供选择 1234desc &quot;snapshot&quot; lane :shot do snapshot end 截图插件的详细使用方式请点击这里 更多可用的参数请点击这里More deliver Uses deliver to upload new app metadata and builds to iTunes Connect上传ipa包到iTunes Connect 可用的参数: app_identifier 应用的bundle id username 开发者账号 12345deliver( app_identifier: options[:appidentifier], username: options[:username] ) 更多可用的参数请点击这里More fastlane buildupload这里提供一个可用的demo来对工程进行自动化打包上传 12345678910111213141516171819202122232425262728293031323334353637383940desc &quot;build your application to an ipa and upload the ipa&quot;desc &quot;if you want upload an ipa to itunes Connect ,please use command line : fastlane buildupload&quot; lane :buildupload do |options| produce( username: options[:username], team_id: options[:teamid], app_identifier: options[:appidentifier], app_name: options[:appname], language: &quot;Simplified Chinese&quot;, app_version: &quot;1.0&quot;, sku: options[:appidentifier], ) cert( username: options[:username], team_id: options[:teamid] ) pem( username: options[:username], team_id: options[:teamid], p12_password: &quot;12345678&quot;, app_identifier: options[:appidentifier], generate_p12: true, output_path: &quot;../#&#123;options[:appname]&#125;/&quot; ) sigh( force: true, username: options[:username], # team_id: options[:teamid], app_identifier: options[:appidentifier] ) clear_derived_data gym( silent: true, clean: true) deliver( app_identifier: options[:appidentifier], username: options[:username] ) end 调用命令：fastlane buildupload 参数1 参数2 参数3 ... 使用shell修改工程配置 在很多情况下我们使用自动化打包工具都是需要批量处理很多工程编译出不同的IPA包的，这就需要我们在使用fastlane之前先修改一些工程的配置 从svn或者git等仓库里面checkout 代码 12rm -rf deploysvn co svn://xxx/xxx/xxx/xxx deploy 从文件里面读取配置信息到数组如: 123456i=0for s in `cat params/appname.txt`do appnames[$&#123;i&#125;]=$&#123;s&#125; i=$&#123;i&#125;+1 done appname.txt文件里面一行写一个app的名字，有几个app就写几行其他的诸如bundle id ，username 等信息类似 修改应用的bundle Id sed -i &#39;&#39; &quot;s/com.xxx.xxx/$1/g&quot; xxx.xcodeproj/project.pbxproj $1，参数一是新的bundle id 修改应用名称 /usr/libexec/PlistBuddy -c &quot;Set :CFBundleDisplayName $2&quot; Jubaodai/Info.plist $2是新的应用名称 修改应用的icons图片 cp -r ../pictures/$2/AppIcon.appiconset/. xxx/Assets.xcassets/AppIcon.appiconset 修改fastlane 元数据里面的应用名称 echo newAppName &gt; fastlane/metadata/zh-Hans/name.txt 修改fastlane 里面上传iTunes Connect 的icon图片 cp ../pictures/$1/app_icon.jpg fastlane/metadata/app_icon.jpg 调用fastlane 进行自动打包 fastlane buildupload username:${usernames[${i}]} teamid:${teamids[${i}]} appidentifier:${appidentifiers[${i}]} appname:${appnames[${i}]} 后续本人开始是使用zip压缩包安装的后来发现无法继续往上升级了，踩了很多坑才升级到新版本了，具体的就不多加赘述只记录几个知识点: 卸载 sudo gem uninstall fastlane 删除 rm -rf ~/.fastlane 重装 sudo gem install -n /usr/local/bin fastlane 如果无法识别fastlane 检查路径配置是否正确export PATH=&quot;$HOME/.fastlane/bin:$PATH&quot; 如果出错 Connection reset by peer - SSL_connect,请检查是否使用RVM ruby命令 rvm list 如果没有使用RVM ruby 请使用rvm ruby ,若没有请先安装rvm osx-ssl-certs update allrvm reinstall ruby-2.3.1 --with-openssl-dir=/usr/local]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>